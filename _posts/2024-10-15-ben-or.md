---
layout: post
title: "Model checking safety of Ben-Or's Byzantine consensus with Apalache"
date: 2024-10-14
categories: specification modelchecking tlaplus apalache
quint: false
tlaplus: true
math: true
---

**Author**: Igor Konnov

This blogpost summarizes my experiments when specifying [Ben-Or's Byzantine
consensus protocol][ben-or] in TLA<sup>+</sup> and model checking it with
[Apalache][]. I presented these results at the [TLA Community Meeting 2024][]
and [VSTTE 2024][]. Both events were great! In fact, the large body of this
blogpost was written on a train from Prague to Vienna. I have already hinted at
some of these results in [Episode 1 of Why I use TLA+ and not(TLA+)][].  This is
one of the examples of definitely using TLA<sup>+</sup>.

Why Ben-Or's consensus? The paper on "Another advantage of free choice:
Completely asynchronous agreement protocols" was published in 1983, which makes
it over 40 years old. However, the algorithms in the paper are using the
primitives that we still find in modern consensus protocols: sending messages to
all processes, counting the number of received messages, using monotonically
increasing rounds. On top of that, the two algorithms Ben-Or use a probabilistic
coin.  We cannot deal with probabilities in Apalache. Hence, we only check its
safety. What I find exciting about this protocol is that it showcases the full
spectrum of the techniques supported by Apalache:

 1. **Randomized symbolic execution** to reason about *some* executions up to
    length $k$,
 
 1. **bounded model checking** to reason about *all* executions up to length
    $k$, and
 
 1. **inductiveness checking** to reason about *all* executions of *all*
    lengths.
 
## 1. Ben-Or's consensus for Byzantine faults

I am not going to set up the scene for the protocol. Ben-Or does it with amazing
clarity. Just read the [paper][ben-or]. It is three pages long, excluding the
references. If you don't need an introduction to consensus, here is the
pseudo-code of the Protocol B, just retyped in markdown:

```
Process P: Initial value x_P
step 0: set r := 1.

step 1: Send the message (1, r, x_P) to all the processes

step 2: Wait till messages of type (1, r, *) are received from N - t processes.
If more than (N + t) / 2 messages have the same value v,
then send the message (2, r, v, D) to all processes.
Else send the message (2, r, ?) to all processes.

step 3: Wait till messages of type (2, r, *) arrive from N - t processes.
(a) If there are at least t + 1 D-messages (2, r, v, D), then set x_P := v.
(b) If there are more than (N + t) / 2 D-messages then decide v.
(c) Else set x_P = 1 or 0 each with probability 1/2.

step 4: Set r := r + 1 and go to step 1.
```

It does not look very complicated, right? The processes send messages around,
receive messages, count the number of received messages and change their states.
There are two challenges to understanding why this algorithm works:

 1. The processes are completely asynchronous. Say, process 1 may be in round 3,
 whereas process 2 may be in round 100.

 1. At most $t$ of $N$ processes may behave Byzantine. They may send conflicting
 messages to the correct processes, or not send any messages at all.

This looks like a good fit for TLA<sup>+</sup> and Apalache.

## 2. Specifying Ben-Or's consensus in TLA<sup>+</sup>

You can find the full specification in [ben-or83][spec]. I wrote the
specification in one go over a weekend, as it was not my first consensus
specification in TLA<sup>+</sup>. However, to explain the abstractions in the
specification, I am presenting it in several steps. The code snippets are
rendered in the Unicode version of TLA<sup>+</sup>. If you would like to see the
ASCII version (which you would normally type), check the [sources][spec] on
Github.

In the following, the paragraphs starting with :bulb: indicate a non-obvious
specification trick.

### 2.1. Declaring specification parameters

Many specifications are parameterized, e.g., in the number of communicating
processes. What kind of parameters do we have in Ben-Or's consensus? Obviously,
we have the total number of processes, which we call `N`. Also, we need the
upper bound on the number of faulty processes, which we call `T` (for
threshold). Since the actual number of faulty processes may differ from `T`, we
will also introduce the actual number of faulty processes, which we call `F`.
Hence, we declare the first three constants as follows:

```tla
CONSTANTS
    \* The total number of processes.
    \* @type: Int;
    N,
    \* An upper bound on the number of faulty processes.
    \* @type: Int;
    T,
    \* The actual number of faulty processes (unknown to the processes).
    \* @type: Int;
    F
```

:bulb: Introducing the parameter $F$ may look like cheating. Indeed, if the
correct processes could read $F$, solving consensus would be much easier.
However, the parameter $F$ is only used to reason about the executions of the
protocol, and it should not be used in the steps executed by the correct
processes.

In order to send messages, we also need process identifiers. To this end,
we introduce two more parameters:

```tla
CONSTANTS
    \* The set of the correct (honest) processes.
    \* @type: Set(REPLICA);
    CORRECT,
    \* The set of the Byzantine (faulty) processes.
    \* @type: Set(REPLICA);
    FAULTY
```

Importantly, when we will specify the protocol behavior, we should not refer to
the constants `CORRECT` and `FAULTY`, as the correct processes do not know the
identities of the faulty processes in a real distributed system. Alternatively,
instead of declaring these two parameters, we could just introduce two sets of
integers:

```tla
CorrectAlt == 1..(N - F)
FaultyAlt == (N - F + 1)..N
```

:bulb: I generally try to avoid integers, when they are not required. Integers
implicitly suggest a total order on process identities, which is not required in
this protocol. Moreover, uninterpreted types such as `REPLICA` are translated to
uninterpreted sorts in SMT, which are more efficient to reason about in SMT in
the general case. In our specification, it would not make a big difference
though.

Since the parameters `N`, `T`, and `F` are in relation with the parameters
`CORRECT` and `FAULTY`, we add the following assumptions about them:

```tla
ASSUME N > 5 * T ∧ Cardinality(CORRECT) = N - F ∧ Cardinality(FAULTY) = F
```

:bulb: We could add one more assumption about the relation between `T` and `F`
such as $T \ge F$. However, it is quite useful to check the cases, where $F >
T$.  The protocol should be unsafe in those cases! Thus, we omit such an
assumption.

Finally, in the above protocol description, round numbers may grow unboundedly
large. For model checking purposes, it is convenient to restrict round numbers
to small sets. To this end, we introduce the set of all rounds as a parameter:

```tla
CONSTANT
    \* The set of rounds, which we bound for model checking.
    \* @type: Set(Int);
    ROUNDS

ASSUME 1 ∈ ROUNDS
```

For proving a theorem, we can still instantiate `ROUNDS` with the set of all
natural numbers `Nat`, but we will instantiate it with small sets such as `0..2`
or `0..5` for model checking.

The protocol needs a few values that could be declared as parameters. However,
we can just use the definitions and assumptions in this case:

```tla
\* The set of values to choose from
VALUES ≜ { 0, 1 }

NO_DECISION ≜ -1
ASSUME NO_DECISION ∉ VALUES

ALL ≜ CORRECT ∪ FAULTY
```

## 2.2. Declaring state variables

After declaring specification parameters, I would usually think about state
variables.

The first portion of state variables is easy to come up with. We can see some
control structure in the pseudo-code, which refers to steps, rounds, values,
and decisions. Hence, we declare the following control state variables:

```tla
VARIABLES
  \* The current value by a process, called $x_P$ in the paper.
  \* @type: REPLICA -> Int;
  value,
  \* The decision by a process, where -1 means no decision.
  \* @type: REPLICA -> Int;
  decision,
  \* The round number of a process, called $r$ in the paper.
  \* @type: REPLICA -> Int;
  round,
  \* The process step: S1, S2, S3.
  \* @type: REPLICA -> STEP;
  step
```

The second portion of state variables is less obvious. We have to somehow model
message-passing in the specification. For this kind of algorithms, the standard
pattern is to store the set of all messages that were sent by the processes.
Hence, we simply declare two state variables to store the sent messages:

```tla
VARIABLES
  \* Type-1 messages sent by the correct and faulty processes, mapped by rounds.
  \* @type: Int -> Set($msgOne);
  msgs1,
  \* Type-2 messages sent by the correct and faulty processes, mapped by rounds.
  \* @type: Int -> Set($msgTwo);
  msgs2
```

Since we had to refer to message types such as `$msgOne` and `$msgTwo`, it is
good time to think about type definitions.

## 2.3. Type definitions

:bulb: It is common to isolate type definitions is a separate file such as
[typedefs.tla][typedefs]. Usually, once we have figured out the type
definitions, we are not going to revisit them much.

To start with, since I have decided to use the uninterpreted type `STEP` to
encode steps, we have to refer to values with the syntax like `"S1_OF_STEP"`.
It is too verbose. Hence, we introduce auxiliary definitions to keep things
tidy:

```tla
\* predefined constants for the steps
S1 ≜ "S1_OF_STEP"
S2 ≜ "S2_OF_STEP"
S3 ≜ "S3_OF_STEP"
```

Now we have to decide on the types of messages. We have messages of type 1,
which look like `(1, r, v)`, and type 2, which look like `(2, r, v, D)` or
`(2, r, ?)`. Hence, for the messages of type 1, it's easy to see that the
record type should be sufficient:

```tla
{ src: REPLICA, r: Int, v: Int }
```

For the messages of type 2, we need to figure out how to encode `(2, r, v, D)`
and `(2, r, ?)`. This looks like a good application for the variant type:

```tla
msgTwo = D({ src: REPLICA, r: Int, v: Int })
       | Q({ src: REPLICA, r: Int });
```

As type annotations have to be written inside comments in front of definitions
in TLA<sup>+</sup>, we declare a dummy definition `type_aliases` and add the
above types as type aliases:

```tla
(*
 * Type definitions:
 *
 * Type-1 messages.
 * @typeAlias: msgOne = { src: REPLICA, r: Int, v: Int };
 *
 * Type-2 messages.
 * @typeAlias: msgTwo = Q({ src: REPLICA, r: Int }) | D({ src: REPLICA, r: Int, v: Int });
 *)
typedefs_aliases ≜ TRUE
```

I prefer to hide the difference between records and variants right in the type
definitions. To this end, we declare the following constructors (not really a
TLA<sup>+</sup> term) and predicates:

```tla
\* @type: (REPLICA, Int, Int) => $msgOne;
M1(src, round, value) ≜ [ src ↦ src, r ↦ round, v ↦ value ]

\* @type: (REPLICA, Int) => $msgTwo;
Q2(src, round) ≜ Variant("Q", [ src ↦ src, r ↦ round ])

\* @type: $msgTwo => Bool;
IsQ2(msg) ≜ VariantTag(msg) = "Q"

\* @type: $msgTwo => { src: REPLICA, r: Int };
AsQ2(msg) ≜ VariantGetUnsafe("Q", msg)

\* @type: (REPLICA, Int, Int) => $msgTwo;
D2(src, round, value) ≜ Variant("D", [ src ↦ src, r ↦ round, v ↦ value ])

\* @type: $msgTwo => Bool;
IsD2(msg) ≜ VariantTag(msg) = "D"

\* @type: $msgTwo => { src: REPLICA, r: Int, v: Int };
AsD2(msg) ≜ VariantGetUnsafe("D", msg)
```

## 2.4. Specifying initial states

Looking at the protocol pseudo-code, initializing the state machine can be done
as trivial as follows:

```tla
Init ≜
  \* non-deterministically choose the initial values
  ∧ value ∈ [ CORRECT → VALUES ]
  ∧ decision = [ r ∈ CORRECT ↦ NO_DECISION ]
  ∧ round = [ r ∈ CORRECT ↦ 1 ]
  ∧ step = [ r ∈ CORRECT ↦ S1 ]
  ∧ msgs1 = [ r ∈ ROUNDS ↦ {}]
  ∧ msgs2 = [ r ∈ ROUNDS ↦ {}]
```

:bulb: We will revisit this decision when modeling faults.

## 2.5. Specifying steps

**Step1.** Step 1 is relatively straightforward:

 - check that a process is at Step 1,

 - send the message,

 - go to Step 2.

This is how we write it in TLA<sup>+</sup>:

```tla
\* @type: REPLICA => Bool;
Step1(id) ≜
  LET r ≜ round[id] IN
  ∧ step[id] = S1
  \* "send the message (1, r, x_P) to all the processes"
  ∧ msgs1' = [msgs1 EXCEPT ![r] = @ ∪ { M1(id, r, value[id]) }]
  ∧ step' = [step EXCEPT ![id] = S2]
  ∧ UNCHANGED ⟨ value, decision, round, msgs2 ⟩
```

**Step2.** Step 2 has more logic than Step 1. In addition to checking that a
process is at Step 2, we have to receive messages and count them.

:bulb: Again, there is a simple pattern of receiving messages in a consensus
protocol:

```tla
  ∃ received ∈ SUBSET msgs1[r]:
    ...
```

This looks too simple! Don't we have to receive message one-by-one and delete
the received messages? It so happens that in consensus algorithms, neither of
these two things are important. A process may receive messages in any order, so,
technically, it may receive an arbitrary subset of the sent messages. When a
process receives too few messages, it does nothing.  So we just have to pick a
large enough subset of messages. To this end, we can just use
`Cardinality(...)`.  Moreover, once a process processed this subset, it is not
going to look at messages of the same shape ever again, as proceeds to the next
step.

Now we have the necessary ingredients to write Step 2:

```tla
Step2(id) ≜
  LET r ≜ round[id] IN
  ∧ step[id] = S2
  ∧ ∃ received ∈ SUBSET msgs1[r]:
     \* "wait till messages of type (1, r, *) are received from N - T processes"
     ∧ Cardinality(Senders1(received)) ≥ N - T
     ∧ LET Weights ≜ [ v ∈ VALUES ↦
          Cardinality(Senders1({ m ∈ received: m.v = v })) ]
        IN
        ∨ ∃ v ∈ VALUES: 
          \* "if more than (N + T)/2 messages have the same value v..."
          ∧ 2 * Weights[v] > N + T
          \* "...then send the message (2, r, v, D) to all processes"
          ∧ msgs2' = [msgs2 EXCEPT ![r] = @ ∪ { D2(id, r, v) }]
        ∨∧ ∀ v ∈ VALUES: 2 * Weights[v] ≤ N + T
          \* "Else send the message (2, r, ?) to all processes"
         ∧ msgs2' = [msgs2 EXCEPT ![r] = @ ∪ { Q2(id, r) }]
  ∧ step' = [ step EXCEPT ![id] = S3 ]
  ∧ UNCHANGED ⟨ value, decision, round, msgs1 ⟩
```

If you look at `Step2` carefully, you will see that we are missing the
definition of `Senders1`. Here is how we define `Senders1` and `Senders2`:

```tla
\* @type: Set($msgOne) => Set(REPLICA);
Senders1(m1s) ≜
  \* Filter the set of ALL, as it has fixed size, in contrast to m1s.
  \* This is especially important, when we call Cardinality on the result.
  { id ∈ ALL: ∃ m ∈ m1s: m.src = id }

\* @type: Set($msgTwo) => Set(REPLICA);
Senders2(m2s) ≜
  \* Filter the set of ALL, as it has fixed size, in contrast to m2s.
  \* This is especially important, when we call Cardinality on the result.
  { id ∈ ALL:
    ∃ m ∈ m2s: (IsD2(m) ∧ AsD2(m).src = id) ∨ (IsQ2(m) ∧ AsQ2(m).src = id) }
```

:bulb: As mentioned in the comments, these definitions are tuned towards the
current implementation of Apalache: The definitions are restricting the small
set `ALL` instead of simply mapping all messages to the sender field.
Otherwise, the constraints for senders will grow as fast as the set of messages,
even though they do not have to. After all, there are not so many process
identities.

The definition of `Step2` still contains one line that may look surprising:

```tla
                  ∧ 2 * Weights[v] > N + T
```

Recall that the pseudo-code contained the statement:

```
If more than (N + t) / 2 messages have the same value v, then...
```

It is easy to overlook that $(N + t) / 2$ is not an integer division,
especially, if you do programming as a daily activity. What is meant here is the
mathematical division, which is done over reals. Obviously, rationals are
sufficient in this case. 

:bulb: Luckily, we do not have to use reals or rationals, as we can simply use
the school math rule:

An equation $x > \frac{a}{b}$, for $b \ne 0$, has a solution if and only if the
equation $b \cdot x > a$ has a solution. This is quite a standard transformation
that drives us from rationals back to integers.

Similarly, the following line encodes the "Else" arm of the statement.
Surprisingly, I introduced a typo there, which I found later!

```tla
        ∨∧ ∀ v ∈ VALUES: 2 * Weights[v] ≤ N + T
```

**Step 3.** Finally, Step 3 is the most complex one, but having understood
steps 1-2, it should be easy to see what is going on:

```tla
Step3(id) ≜
  LET r ≜ round[id] IN
  ∧ step[id] = S3
  ∧ ∃ received ∈ SUBSET msgs2[r]:
    \* "Wait till messages of type (2, r, *) arrive from N - T processes"
    ∧ Cardinality(Senders2(received)) = N - T
    ∧ LET Weights ≜ [ v ∈ VALUES ↦
             Cardinality(Senders2({ m ∈ received: IsD2(m) ∧ AsD2(m).v = v })) ]
       IN
       ∨ ∃ v ∈ VALUES: 
          \* "(a) If there are at least T+1 D-messages (2, r, v, D),
          \* then set x_P to v"
          ∧ Weights[v] ≥ T + 1
          ∧ value' = [value EXCEPT ![id] = v]
          \* "(b) If there are more than (N + T)/2 D-messages..."
          ∧ IF 2 * Weights[v] > N + T
             \* "...then decide v"
             THEN decision' = [decision EXCEPT ![id] = v]
             ELSE decision' = decision
       ∨ ∧ ∀ v ∈ VALUES: Weights[v] < T + 1
         ∧ ∃ next_v ∈ VALUES:
             \* "(c) Else set x_P = 1 or 0 each with probability 1/2."
             \* We replace probabilites with non-determinism.
             ∧ value' = [value EXCEPT ![id] = next_v]
             ∧ decision' = decision
    \* the condition below is to bound the number of rounds for model checking
    ∧ r + 1 ∈ ROUNDS
    \* "Set r := r + 1 and go to step 1"
    ∧ round' = [ round EXCEPT ![id] = r + 1 ]
    ∧ step' = [ step EXCEPT ![id] = S1 ]
    ∧ UNCHANGED ⟨ msgs1, msgs2 ⟩
```

If you look at the definition carefully, you will see that we have merged steps
3 and 4, as step 4 does nothing more than increasing the round number.

:bulb: In comparison to the pseudo-code, we have introduced one additional
constraint:

```tla
    \* the condition below is to bound the number of rounds for model checking
    ∧ r + 1 ∈ ROUNDS
```

The purpose of the above condition is to restrict the execution space of the
algorithm to the values in the set `ROUNDS`. When we set `ROUNDS` to `Nat`, The
above condition is trivially true. When we set `ROUNDS` to a small interval
`1..m`, we restrict the search space. Actually, in this algorithm, setting
`ROUNDS` to a finite set makes the state-space finite. In theory, we could use
the model checker TLC to exhaustively enumerate all states. In practice, the
state space of this algorithm is too large even for as small sets of rounds as
`0..2`.

## 2.6. Checking the behavior of the correct processes

Before we dive into potential faults, it is always a good idea to check the
properties of the fault-free behavior. To this end, we have all the ingredients
ready. It only remains to put together steps 1-3:

```tla
CorrectStep ≜
  ∃ id ∈ CORRECT:
    ∨ Step1(id)
    ∨ Step2(id)
    ∨ Step3(id)
```

Having `Init` and `CorrectStep`, we use Apalache to produce interesting
examples. For instance, let's define two invariants:

```tla
\* An example of a process that has made a decision
DecisionEx ≜
    ¬(∃ id ∈ CORRECT: decision[id] ≠ NO_DECISION)

\* An example of all correct processes having made a decision
AllDecisionEx ≜
    ¬(∀ id ∈ CORRECT: decision[id] ≠ NO_DECISION)
```

These invariants are intended to be violated. This is why I've added the suffix
`Ex` to their names, for an "example". Indeed, these "falsy" invariants are good
for generating examples.

```sh
$ apalache-mc check --length=30 --inv=DecisionEx --init=Init --next=CorrectStep MC_n6t1f1.tla
...
State 11: Checking 1 state invariants
Check the trace in: ...
State 11: state invariant 0 violated.
Total time: 8.502 sec
```

Not bad. We have found an execution that leads to a state, in which one of the
correct processes made a decision. The example has 11 steps, the last of them
containing the following value for `decision`:

```tla
State11 ==
  decision
      = SetAsFun({ <<"1_OF_REPLICA", -1>>,
        <<"4_OF_REPLICA", -1>>,
        <<"3_OF_REPLICA", -1>>,
        <<"2_OF_REPLICA", -1>>,
        <<"0_OF_REPLICA", 1>> })
  ...
```

:bulb: Apalache outputs a function `F` as `SetAsFun(S)`, where `S` is the set of
pairs `<<x, F[x]>>`, for `x ∈ DOMAIN F`. We find this notation a bit more
accessible than the one produced by TLC:

```tla
  ("1_OF_REPLICA" :> -1) @@ ("4_OF_REPLICA" :> -1)
    @@ ("3_OF_REPLICA" :> -1) @@ ("2_OF_REPLICA" :> -1) @@ ("0_OF_REPLICA" :> 1)
```

Further, we look for an example of an execution that ends up in a state, where all
correct processes made a decision. Apalache finds such an example in about one minute:

```sh
$ apalache-mc check --length=30 --inv=AllDecisionEx --init=Init --next=CorrectStep MC_n6t1f1.tla
State 15: Checking 1 state invariants
Check the trace in: ...
State 15: state invariant 0 violated.
Total time: 67.629 sec
```

## 2.7. Specifying faults


[ben-or]: https://dl.acm.org/doi/10.1145/800221.806707
[TLA Community Meeting 2024]: https://conf.tlapl.us/2024-fm/
[VSTTE 2024]: https://www.soundandcomplete.org/vstte2024.html
[Apalache]: https://apalache-mc.org
[spec]: https://github.com/konnov/apalache-examples/tree/main/ben-or83
[tlauc]: https://github.com/tlaplus-community/tlauc
[typedefs]: https://github.com/konnov/apalache-examples/blob/main/ben-or83/typedefs.tla
[main]: https://github.com/konnov/apalache-examples/tree/main/ben-or83/Ben_or83.tla
[Episode 1 of Why I use TLA+ and not(TLA+)]: ./2024-09-28-tla-and-not-tla.md