---
layout: post
title: "Thinking about a random number generator"
date: 2024-01-02
categories: quint
quint: true
typescript: true
math: true
---

**Foreword.** This is my first post about protocol specification since I have
left [Informal Systems][]. Having a bit of free time on my hands, I want to
show everyone how to think about code and protocols with specification
languages such as [TLA+][] and [Quint][] as well as with tools such as
[Apalache][] and [TLC][]. There are no patented methods behind. As with
programming languages, you just need to practice and get a bit of expertise in
using these tools.  Obviously, I am biased towards [Quint][] and [Apalache][].
I believe both projects are great, but it's not my job to sell them to you
:cocktail:.

## 1. The Story

In this blog post, I am going to tell you a story about how I realized that the
[Quint][] simulator had a subtle bug in its pseudorandom number generator, or
just [PRNG][]. If you have not heard about Quint yet, check its [landing
page](https://github.com/informalsystems/quint). In short, Quint is a language
and a set of tools for specifying and checking distributed protocols, which is
inspired by the logic of $\tla{}$. Personally, I am using Quint as replacement
of pen and paper, whenever I have to think about tricky code and protocols.
Before Quint, I was using $\tla{}$, [Apalache][], and [TLC][] for the same
purpose. The PRNG is an example of tricky code that did not fit into my brain.

By the way, [Quint license][] is [Apache 2.0][]. This is why I feel free
talking about its code, and you can do that too :open_hands:.

Going back to the story, Quint has a randomized simulator. This simulator lets
you quickly try thousands of specification runs without thinking too much.
This is quite convenient for busy developers. If the simulator finds a bug,
you know that the specification is broken. If it does not find a bug, you may
want to think about running more advanced tools like a model checker.  Many
people I know stop after making the simulator happy, introduce randomized tests
in their Github actions and hope that the simulator finds a bug in the CI one
day, if there is a bug. If this sounds a lot like [Property-based testing][] to
you, you are completely right. Popularity of tools like [Proptest][] among
engineers led us to the idea of introducing the randomized simulator in Quint.
Moreover, [Vanlightly and Kuppe'22][] presented the idea of randomized
simulation at the [TLA+ Conference 2022][]. (They did even more than that by
evaluating statistical properties.)

### 1.1. Why is the Quint Simulator Randomized?

Why do we say that the Quint simulator is randomized? After all, many
expressions are completely deterministic and do not require any randomization.
For instance, have a look at the following expressions:

```quint
2 + 3
2.to(10).forall(i => i > 0)
Set(3, 4, 6).map(i => i * 2)
```

We can easily evaluate these expressions with Quint REPL:

```quint
$ quint
Quint REPL 0.17.1
Type ".exit" to exit, or ".help" for more information
>>> 2 + 3
5
>>> 2.to(10).forall(i => i > 0)
true
>>> Set(3, 4, 6).map(i => i * 2)
Set(12, 6, 8)
>>>
```

We should get the same output in REPL no matter how many times we are
evaluating the expressions. Things are getting more interesting when we look at
Quint actions, which may read from and write to state variables. For instance:

```quint
$ quint
Quint REPL 0.17.1
Type ".exit" to exit, or ".help" for more information
>>> var temperature: int
>>> // declare actions to increase or decrease the temperature
>>> action inc(i) = { temperature' = temperature + i }

>>> action dec(i) = { temperature' = temperature - i }

>>> temperature' = 0
true
>>> temperature
0
>>> inc(2)
true
>>> temperature
2
>>> inc(3)
true
>>> temperature
5
```

If you are having hard time when you are trying to understand the REPL session,
Quint has a detailed [REPL Tutorial][].

Our example above is still perfectly deterministic. Now have a look at this
continuation of the REPL session:

```quint
>>> any { inc(2), dec(3) }
true
>>> temperature
2
>>> any { inc(2), dec(3) }
true
>>> temperature
4
>>> any { inc(2), dec(3) }
true
>>> temperature
6
>>> any { inc(2), dec(3) }
true
>>> temperature
3
```

As you can see, in some cases `inc(2)` has been applied, whereas in other
cases, `dec(3)` has been applied. This is due to the semantics of `any`: It
applies one of the actions that may return `true` (such actions are called
*enabled*). In our example, `any` is free to choose between `inc(2)` and
`dec(3)`, and we do not have control over how it chooses `inc` or `dec`.  In
other words, `any` exhibits *control non-determinism*. The Quint
simulator is a relatively simple tool that resolves non-determinism via random
choice between the enabled actions. If you know $\tla{}$, the Quint action
`any { inc(2), dec(3) }` would look like this in $\tla{}$:

$inc(2) \lor dec(3)$

Now let's try something different:

```quint
>>> nondet j = 1.to(2^256).oneOf(); inc(j)
true
>>> temperature
104805969134431997431573760118265476950429701228807521497918427101053555018189
>>> nondet j = 1.to(2^256).oneOf(); inc(j)
true
>>> temperature
116861016918330452735960921129257808479973548559971540977669281888148973858288
```

This time, we have used the nondet-binding, which exhibits *data
non-determinism*. As you have probably guessed, the simulator has simply picked
two random numbers in the range from 1 to $2^{256}$. If you know $\tla{}$, the
above nondet-binding could be written as follows in $\tla{}$:

$\exists j \in 1..2^{256}: inc(j)$

### 1.2. How to Pick Random Numbers?

The title of this section looks silly. Every programming language has
a library for generating random numbers, right? Well, we have a few specific
requirements:

 1. We want our experiments to be reproducible. Hence, we need not so random
   "random" numbers, that is, we need pseudo-random numbers as in [PRNG][].
   PNRGs are deterministic: If you know the seed, you should be able to
   reproduce an experiment. Random number generators that read mouse movements
   or something similar are not good fit for this job. They are great for
   cryptography algorithms, but not for simulations.

 1. As the simulator is exercising multiple runs, it would be great, if we
 could read the current state of the PRNG and use it as a seed later.

 1. We need a PRNG that is able to generate big integers, that is, we can give
 a PRNG a bound for every integer to be generated, but we cannot give it an
 ultimate bound on all integers to be generated.

Luckily for us, [Widynski'22][] have published their paper on "Squares: A Fast
Counter-Based RNG". This generator ticks off our requirements (1) and (2).
Unfortunately, it only produces 32-bit integers. So we are left with (3) as a
take-home exercise. I thought that it was an easy exercise, and this led to
accidental introduction of a bug :beetle:

### 1.3. PRNG for Big Integers

We have implemented the generator `square64` from the paper by [Widynski'22][].
It produces up to $2^{64}$ pseudo-random 32-bit integers. You can check the
[square64 code][]. This code is a simple adaptation of the original C code from
the paper. Since Quint is written in TypeScript, our implementation does not
seem to be very efficient. We could have implemented it in AssemblyScript or
Rust instead. However, `square64` did not seem to be a performance bottleneck
to us.

Finally, here is [my code][] that implements a PRNG for big integers by
calling `square64`:

<a id="prng-code" />

```ts
export const newRng = (initialState?: bigint): Rng => {
  let state: bigint = initialState ?? BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER))
  // ...
  return {
    // 2^32 as bigint
    const U32: bigint = 0x100000000n
    // 2^64 as bigint
    const U64: bigint = 0x10000000000000000n
    // Given a bound and the current state, produce a big integer below the bound.
    next: (bound: bigint): bigint => {
      assert(bound > 0n)
      let input: bigint = bound
      let output: bigint = 0n
      let base: bigint = 1n
      while (input >= U32) {
        // produce pseudo-random least significant 32 bits,
        // while shifting the previous output to the left
        output = output * U32 + squares64(state)
        // advance the RNG state, while staying within 64 bits
        state = (state + 1n) % U64
        // forget the least significant 32 bits of the input
        input /= U32
        // shift the base by 32 bits to the left
        base *= U32
      }
      // Now we have to be careful to make `output` in the range [0, bound).
      // Produce 32 bits. Since we are using the modulo operator here,
      // the result is not exactly the uniform distribution.
      // It may be biased towards some values, especially for
      // the small values of `bound`. If this becomes a problem in the future,
      // we should figure out, how to make the distribution uniform.
      output = (squares64(state) % input) * base + output
      // advance the RNG state, while staying within 64 bits
      state = (state + 1n) % U64
      return output
    },
  }
}
```

As you can see, the code is heavily documented. When I was writing it, it
looked obvious to me. Recently, I had a fresh look at it, and something seemed
off. What worried me is that the variable `bound` was not taken into account
inside the loop at all. My first hypothesis was that this could produce
`output` larger than `bound`. Obviously, I was concerned about this property
before, and this is why [rng.test.ts][] has a number of tests that check
exactly this property. Moreover, we could test the main property of `next` as
an assertion just before the `return` statement:

```ts
    { // ...
      assert(output < bound)
      return output
    }
```

Such an assertion at the end of a function is usually called a *postcondition*.
If you noticed the statement `assert(bound > 0n)` in the beginning of the
function, this is our *precondition*. Typically, verification tools introduce
domain-specific languages for writing pre- and postconditions.

We already have randomized tests. They periodically run in the CI, but they do
not catch any bugs. However, I still do not trust that my code is doing
what it is supposed to do. What shall we do here? Twenty years ago, my standard
answer would be: Get a piece of paper and a cup of coffee, think about the
code. Can we do better, having all these computers around? Of course, it is
the year 2024. Yes, I have tried ChatGPT on this code. It did not help me
much. Actually, it lied in my face :smile:.

At that point, I did not want to go into the code verification tools. If I
wanted to do so, [Dafny][] would be my usual suspect.

Of course, my first thought was: Can we use Quint to check the generator logic?
:innocent:

## 2. Specifying PRNG in Quint

Before we go into specification, we should ask ourselves several
questions:

 1. What concern does the specification address? For example, are we more
 worried about the code logic being flawed, or do we really have to figure
 out the distribution of our PRNG?

 1. Do we want to specify the code as it is, or do we want to forget some
 "less important" pieces?

 1. Do we want to write a specification for arbitrarily-long integers,
 or, say, sequences up to ten 32-bit integers would suffice?

Since my goal is to understand, whether the generator logic is flawed, or not,
my answers to these questions are as follows:

 1. The specification should follow the code logic. Whether the generator's
 distribution is uniform is less important to me at the moment. It is important
 though that for every integer $i$ from the interval $[0, bound)$, the
 probability of producing $i$ is greater than 0. It is also important to me
 that the generator always produces values within the bounds.

 1. We do not care about the exact behavior of `square64`. However, it is
 important that `square64` generates all integers in the interval $[0,
 2^{32})$. This means that we want to replace `square64` with something more
 abstract. We will see how to do it below. Since the variable `state` only
 interacts with `square64`, we can simply drop this variable. What we are
 doing here is usually called an *overapproximation* of the behavior.

 1. It's fine to start with the specification of big integers that could be
 packed into up to three 32-bit words. By having three words, we can exercise
 up to two loop iterations, which should be the minimal interesting case.
 Actually, to ease the spec debugging, I would even start with 8-bit words
 instead of 32-bit. What we are doing here is usually called an
 *underapproximation* of the behavior. Importantly, we should write a
 specification in such a way that it would be easy to generalize it.

Usually, I am writing a protocol specification in several steps: Starting
with the most obvious parts and continuing with the most challenging ones.
In this post, we will do it the same way.

**Warning:** A lot of text follows. It actually took me maybe 15-30 minutes to
write a complete Quint specification and experiment with it. However,
presenting and understanding the specification thought process takes more
effort.

### 2.1. Specifying the control loop

Following $\tla{}$, Quint is built around the concept of a state machine. If I
asked you to draw a state machine of the [PRNG code](#prng-code), there is a
good chance that you would draw a diagram similar to the one below:

<a id="pc-diagram" />

<!-- once Github pages support mermaid, use img/prng1-control.mermaid -->

![Control diagram]({{ site.baseurl }}/img/prng1-control.png)

While this is not exactly the same state machine that $\tla{}$ experts would
have imagined, this is a good starting point. Basically, we initialize the
state machine, run it in a loop for a while, and, then, we are done. This is
what we specify in the first version: [prng1.qnt]({{ site.baseurl
}}/specs/prng1.qnt).

For the readers unfamiliar with Quint, we introduce this specification in
smaller pieces that are easier to digest. The pieces to be defined later are
written in `<<<...>>>`.

```quint
module prng1 {
  type PC = | InLoop | Done
  var pc: PC

  <<<initialisation>>>

  <<<step>>>
}
```

Since the [PRNG code](#prng-code) is single-threaded, we introduce one variable
`pc`, which stands for a *program counter*, similar to [Program counter][] in
hardware. Quint is a typed language, so we had to declare the type associated
with the variable `pc`, that is, the type `PC`. As a result, our variable `pc`
can be assigned one of the two values: `Loop` or `Done`. If you want to learn
more about the type declaration of `PC`, check [Sum Types][] in the Quint
language reference.

**Machine Initialisation.** This is how we initialize our state machine:

```quint
  action init: bool = {
    pc' = InLoop
  }
```

This part should be easy to understand. Once `init` is evaluated,
the variable `pc` has the value `InLoop`, as prescribed by `pc' = InLoop`.

**Machine Step.** Similar to the [the diagram](#pc-diagram), we introduce the
action `step`, which non-deterministically chooses between two other actions:
`loop` and `postLoop`.

```quint
  action step = any {
    loop,
    postLoop,
  }

  <<<actions>>>
```

Finally, the actions `loop` and `postLoop` are defined as follows:

```quint
  action loop: bool = all {
    pc == InLoop,
    pc' = InLoop,
  }

  action postLoop: bool = all {
    pc == InLoop,
    pc' = Done,
  }
```

**Exercising the Machine.** Our specification is not very useful, but it's
not entirely useless either. We can play with it in REPL and convince ourselves
that it specifies the same behavior as shown in [the diagram](#pc-diagram):

```quint
$ quint -r specs/prng1.qnt::prng1
Quint REPL 0.17.1
Type ".exit" to exit, or ".help" for more information
>>> init
true
>>> pc
InLoop
>>> loop
true
>>> loop
true
>>> postLoop
true
>>> pc
Done
```

Once we have played enough with this specification, let's add the interesting
part to the state machine, that is, *data*.

### 2.2. Adding data




[Informal Systems]: https://informal.systems
[TLA+]: https://lamport.azurewebsites.net/tla/tla.html
[Quint]: https://github.com/informalsystems/quint
[Apalache]: https://github.com/informalsystems/apalache
[TLC]: https://lamport.azurewebsites.net/tla/tools.html
[PRNG]: https://en.wikipedia.org/wiki/Pseudorandom_number_generator
[Property-based testing]: https://en.wikipedia.org/wiki/Software_testing#Property_testing
[Proptest]: https://crates.io/crates/proptest
[Vanlightly and Kuppe'22]: https://www.youtube.com/watch?v=cYenTPD7740
[my code]: https://github.com/informalsystems/quint/blob/8eca8a2db4f088130c8d485436c365384d3f4c6b/quint/src/rng.ts#L80-L108
[TLA+ Conference 2022]: https://conf.tlapl.us/2022/
[REPL Tutorial]: https://github.com/informalsystems/quint/blob/main/tutorials/repl/repl.md
[Widynski'22]: https://arxiv.org/abs/2004.06278
[square64 code]: https://github.com/informalsystems/quint/blob/8eca8a2db4f088130c8d485436c365384d3f4c6b/quint/src/rng.ts#L120-L160
[rng.test.ts]: https://github.com/informalsystems/quint/blob/8eca8a2db4f088130c8d485436c365384d3f4c6b/quint/test/rng.test.ts
[Dafny]: https://dafny.org/
[Apache 2.0]: https://www.apache.org/licenses/LICENSE-2.0
[Quint License]: https://github.com/informalsystems/quint/blob/8eca8a2db4f088130c8d485436c365384d3f4c6b/LICENSE
[Program counter]: https://en.wikipedia.org/wiki/Program_counter
[Sum Types]: https://github.com/informalsystems/quint/blob/main/doc/lang.md#sum-types
