---
layout: post
title: "Thinking about a random number generator"
date: 2024-01-02
categories: quint
---

**Foreword.** This is my first post about protocol specification since I have
left [Informal Systems][]. Having a bit of free time on my hands, I want to
show everyone how to think about code and protocols with
specification languages such as [TLA+][] and [Quint][] as well as with tools
such as [Apalache][] and [TLC][]. Obviously, I am biased towards [Quint][] and
[Apalache][]. I believe both projects are great, but it's not my job to sell
them to you :cocktail:

## 1. The Story

In this blog post, I am going to tell you a story about how I realized that the
[Quint][] simulator had a subtle bug in its pseudorandom number generator, or
just [PRNG][]. If you have not heard about Quint yet, check its [landing
page](https://github.com/informalsystems/quint). In short, Quint is a language
and a set of tools for specifying and checking distributed protocols, which is
inspired by the logic of [TLA+][]. Personally, I am using Quint as replacement
of pen and paper, whenever I have to think about tricky code and protocols.
Before Quint, I was using TLA+ for the same purpose. The PRNG is an example of
tricky code that did not fit into my brain.

Going back to the story, Quint has a randomized simulator. This simulator lets
you quickly try thousands of specification runs without thinking too much.  If
the simulator finds a bug, you know that the specification is broken. If it
does not find a bug, you may want to think about running more advanced tools
like a model checker. Many people I know stop after making the simulator happy,
introduce randomized tests in their Github actions and hope that the simulator
finds a bug in the CI one day, if there is a bug. If this sounds a lot like
[Property-based testing][] to you, you are completely right. Popularity of
tools like [Proptest][] among engineers led us to the idea of introducing the
randomized simulator in Quint. Moreover, [Vanlightly and Kuppe'22][] presented
the idea of randomized simulation at the [TLA+ Conference 2022][]. (They did
more than that by evaluating statistical properties.)

### 1.1. Why is the Quint Simulator Randomized?

Why do we say that the Quint simulator is randomized? After all, many
expressions are completely deterministic and do not require any randomization.
For instance, have a look at the following expressions:

```bluespec
2 + 3
2.to(10).forall(i => i > 0)
Set(3, 4, 6).map(i => i * 2)
```

We can easily evaluate these expressions with Quint REPL:

```sh
$ quint
Quint REPL 0.17.1
Type ".exit" to exit, or ".help" for more information
>>> 2 + 3
5
>>> 2.to(10).forall(i => i > 0)
true
>>> Set(3, 4, 6).map(i => i * 2)
Set(12, 6, 8)
>>>
```

We should get the same output in REPL no matter how many times we are
evaluating the expressions. Things are getting more interesting when we look at
Quint actions, which may read from and write to state variables. For instance:

```bluespec
$ quint
Quint REPL 0.17.1
Type ".exit" to exit, or ".help" for more information
>>> var temperature: int
>>> // declare an action that increase the temperature variable
>>> action inc(i) = { temperature' = temperature + i }

>>> action dec(i) = { temperature' = temperature - i }

>>> temperature' = 0
true
>>> temperature
0
>>> inc(2)
true
>>> temperature
2
>>> inc(3)
true
>>> temperature
5
```

If you are having hard time when you are trying to understand the REPL session,
Quint has a detailed [REPL Tutorial][].

Our example above is still perfectly deterministic. Now have a look at this
continuation of the REPL session:

```bluespec
>>> any { inc(2), dec(3) }
true
>>> temperature
2
>>> any { inc(2), dec(3) }
true
>>> temperature
4
>>> any { inc(2), dec(3) }
true
>>> temperature
6
>>> any { inc(2), dec(3) }
true
>>> temperature
3
```

As you can see, in some cases `inc(2)` has been applied, whereas in other
cases, `dec(3)` has been applied. This is due to the semantics of `any`: It
applies one of the actions that may return `true` (such actions are called
*enabled*). In our example, `any` is free to choose between `inc(2)` and
`dec(3)`, and we do not have control over how it chooses `inc` or `dec`.  In
other words, `any` exhibits *control non-determinism*. If you know TLA+, `any {
inc(2), dec(3) }` would look like `inc(2) \/ dec(3)` in TLA+. The Quint
simulator is a relatively simple tool that resolves non-determinism via random
choice between the enabled actions.

Now let's try something different:

```bluespec
>>> nondet j = 1.to(2^256).oneOf(); inc(j)
true
>>> temperature
104805969134431997431573760118265476950429701228807521497918427101053555018189
>>> nondet j = 1.to(2^256).oneOf(); inc(j)
true
>>> temperature
116861016918330452735960921129257808479973548559971540977669281888148973858288
```

This time, we have used the nondet-binding, which exhibits *data
non-determinism*. As you have probably guessed, the simulator has simply picked
two random numbers in the range from 1 to $2^{256}$. If you know TLA+, the
above nondet-binding could be written as `\E j \in 1..2^256: inc(j)` in TLA+.

### 1.2. How to Pick Random Numbers?

The title of this section looks silly. Every programming language has
a library for generating random numbers, right? Well, we have a few specific
requirements:

 1. We want our experiments to be reproducible. Hence, we need not so random
   "random" numbers, that is, we need pseudo-random numbers as in [PRNG][].
   PNRGs are deterministic: If you know the seed, you should be able to
   reproduce an experiment. Random number generators that read mouse movements
   or something similar are not good fit for this job. They are great for
   security algorithms, but not for simulations.

 1. As the simulator is trying multiple runs, it would be great, if we could
   read the current state of the PRNG and use it as a seed later.

 1. We need a PRNG that is able to generate big integers, that is, we can give
 a PRNG a bound for every integer to be generated, but we cannot give it an
 ultimate bound on all integers to be generated.

Luckily for us, [Widynski'22][] have published their paper on "Squares: A Fast
Counter-Based RNG". This generator ticks off points (1) and (2). Unfortunately,
it only produces 32-bit or 64-bit integers. So we are left with (3) as a
take-home exercise. I thought that it was an easy exercise, and this led to
accidental introduction of a bug :beetle:

### 1.3. PRNG for Big Integers

We have implemented the generator `square64` from the paper by [Widynski'22][].
It produces up to $2^64$ pseudo-random 32-bit integers.  You can check the
[square64 code][]. The code is a simple adaptation of the original C code from
the paper. Since Quint is written in TypeScript, our implementation does not
seem to be very inefficient. We could have implemented it in AssemblyScript
instead. However, `square64` does not seem to be the performance bottleneck.

Finally, here is [my code][] that implements a PRNG for big integers by
calling `square64`:

```typescript
    // 2^32 as bigint
    const U32: bigint = 0x100000000n
    // 2^64 as bigint
    const U64: bigint = 0x10000000000000000n
    // Given a bound and the current state,
    // produce a big integer below the bound.
    // Note that `state` is a variable declared outside of `next`.
    next: (bound: bigint): bigint => {
      assert(bound > 0n)
      let input: bigint = bound
      let output: bigint = 0n
      let base: bigint = 1n
      while (input >= U32) {
        // produce pseudo-random least significant 32 bits,
        // while shifting the previous output to the left
        output = output * U32 + squares64(state)
        // advance the RNG state, while staying within 64 bits
        state = (state + 1n) % U64
        // forget the least significant 32 bits of the input
        input /= U32
        // shift the base by 32 bits to the left
        base *= U32
      }
      // Now we have to be careful to make `output` in the range [0, bound).
      // Produce 32 bits. Since we are using the modulo operator here,
      // the result is not exactly the uniform distribution.
      // It may be biased towards some values, especially for
      // the small values of `bound. If it becomes a problem in the future,
      // we should figure out, how to make the distribution uniform.
      output = (squares64(state) % input) * base + output
      // advance the RNG state, while staying within 64 bits
      state = (state + 1n) % U64
      return output
    },
```

As you can see, the code is heavily documented. When I was writing it, it
looked obvious to me. Then, I had a fresh look at it recently, and something
was off. What worried me is that the variable `bound` is not taken into
account inside the loop at all. My first hypothesis was that this could produce
`output` larger than `bound`. Obviously, I was concerned about this property
before, and this is why [rng.test.ts][] has a number of tests that check
exactly this property. Moreover, the main property of `next` could be added as
an assertion just before the `return` statement:

```typescript
      // ...
      assert(output < bound)
      return output
    },
```

Such an assertion at the end of a function is usually called a *postcondition*.
If you noticed the `assert(bound > 0n)` in the beginning of the function, this
is our *precondition*. Typically, verification tools introduce specialized
domain-specific languages for writing pre- and postconditions.

At that point, I did not want to go into the code verification tools. If I
wanted to do so, [Dafny][] would be my usual suspect.

Of course, my first thought was: Can we use Quint to check this generator?
:innocent:


[Informal Systems]: https://informal.systems
[TLA+]: https://lamport.azurewebsites.net/tla/tla.html
[Quint]: https://github.com/informalsystems/quint
[Apalache]: https://github.com/informalsystems/apalache
[TLC]: https://lamport.azurewebsites.net/tla/tools.html
[PRNG]: https://en.wikipedia.org/wiki/Pseudorandom_number_generator
[Property-based testing]: https://en.wikipedia.org/wiki/Software_testing#Property_testing
[Proptest]: https://crates.io/crates/proptest
[Vanlightly and Kuppe'22]: https://www.youtube.com/watch?v=cYenTPD7740
[my code]: https://github.com/informalsystems/quint/blob/8eca8a2db4f088130c8d485436c365384d3f4c6b/quint/src/rng.ts#L80-L108
[TLA+ Conference 2022]: https://conf.tlapl.us/2022/
[REPL Tutorial]: https://github.com/informalsystems/quint/blob/main/tutorials/repl/repl.md
[Widynski'22]: https://arxiv.org/abs/2004.06278
[square64 code]: https://github.com/informalsystems/quint/blob/8eca8a2db4f088130c8d485436c365384d3f4c6b/quint/src/rng.ts#L120-L160
[rng.test.ts]: https://github.com/informalsystems/quint/blob/8eca8a2db4f088130c8d485436c365384d3f4c6b/quint/test/rng.test.ts
[Dafny]: https://dafny.org/
