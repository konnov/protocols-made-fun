---
layout: post
title: "You should not care about memory in protocol specifications"
date: 2024-01-13
categories: quint
quint: true
typescript: true
math: true
---

*...Unless you are specifying a garbage collector.*

I have written about 1100 lines of [Quint][] over this week. Similar to my
experience of writing [TLA+][] specifications, what I noticed again is that
there is a big difference in my specification style that depends on where I
start from:

 1. **Source code.** This is the case when a protocol already has an
 implementation. In this case, there is a high chance that the code is the only
 reliable source of truth. Even if there is a high-level protocol
 specification, it either too imprecise or outdated. Arguably, having an
 outdated protocol specification is still better than having no specification
 at all. Typically, the code is "working", but it is not exactly clear what
 happens if things "go wrong".

 1. **Specification in English.** This is the case when a protocol is still in
 the design phase. The project may already have a code prototype, but there is
 a lot of uncertainty about failure scenarios. Typically, the only known thing
 known at this stage is the "happy path", that is, an example of how the
 protocol is supposed to work, when "nothing wrong" happens.

This time I started with the source code, having essentially no specification.
When you are starting with the code, it is very tempting to use exactly the
same data structures and operations, as you see them in the code. This is
usually a mistake! The rule that I have learned over multiple iterations is as
follows:

*The data structures in a protocol specification shall be more abstract than
the data structures in the source code.*

Every time I deviate from this rule, I have to re-learn it. There are many
instances of this rule. In this blog post, I am focusing only on one instance
of the rule: The use of maps and the memory considerations that are related to
this data structure.

## 1. What are maps?

If you are developing software, there is a very good chance that you have been
using maps. They have slightly different names in different programming
languages: `HashMap` and `SortedMap` in Java/Scala, a `map` in Go, `HashMap`
and `BTreeMap` in Rust, dictionaries in Python, `mapping` in Solidity, etc.
These data structures have slightly different names in different programming
languages but they all have more or less the same abstract behavior. Since
there is no common denominator in programming languages, I am using [Quint
REPL][] to demonstrate this abstract behavior:

 1. **Construct a map**. Construct an empty map. Alternatively, construct a non-empty
 map by enumerating key-value pairs. This is done with `Map(...)` in Quint:
   ```quint
   $ quint
   >>> Map()
   Map()
   >>> Map("alice" -> 3, "bob" -> 5)
   Map("alice" -> 3, "bob" -> 5)
   ```

 1. **Add or update a key-value pair**. Bind a value to a key in a map. For example,
 bind the value 42 to the key `"igor"`. Importantly, if the map already has a
 value bound to the key, update the entry, so the key becomes associated with
 the new value. This is done with `put` in Quint:
   ```quint
   $ quint
   >>> Map().put("igor", 42)
   Map("igor", 2024)
   >>> Map("igor" -> 41, "bob" -> 5).put("igor", 42)
   Map("igor" -> 42, "bob" -> 5)
   ```

 1. **Update a key-value pair**. If a value $v_1$ is bound to a key $k$ in a
 map, then bind a new value $v_2$ to the key $k$. If the map does not have a
 value for the key $k$, then the behavior is either undefined, or an error
 is expected (this varies from a language to language). This is done
 with `set` in Quint:
   ```quint
   $ quint
   >>> Map("igor" -> 41, "bob" -> 5).set("igor", 42)
   Map("igor" -> 42, "bob" -> 5)
   >>> Map().set("igor", 42)
   runtime error: error: [QNT507] Called 'set' with a non-existing key
    ```

 1. **Retrieve the value.** Given a key $k$, retrieve the value bound to the
 key in a map. Usually, it is assumed that there must be such a value.
 Otherwise, the behavior is either undefined, or an error is expected.
 This is done with `get` in Quint:
   ```quint
   $ quint
   >>> Map("igor" -> 41, "bob" -> 5).get("igor")
   Map("igor" -> 42, "bob" -> 5)
   >>> Map().get("igor")
   runtime error: error: [QNT507] Called 'get' with a non-existing key
   ```

 1. **Get the keys.** Get the keys that are bound to some values in a map.
 What is actually returned, depends on a programming language. It can be a
 list, an array, a set, or an iterator. Quint returns the set of keys:
   ```quint
   $ quint
   >>> Map("alice" -> 3, "bob" -> 7).keys()
   Set("alice", "bob")
   ```

Programming languages usually have another operation that iterates over
key-value pairs. The way it looks like usually depends on the language. I am
omitting this operation here, as it can be implemented via a combination of
`keys`, `get`, and iteration. Similar to that, many languages have an operation
`m.contains(k)` for checking whether a key $k$ has a value bound to $k$ in a
map $m$. This one can be implemented via `m.keys()` and its set membership:
`m.keys().contains(k)`.

If you know $\tla{}$ or Quint, you know that they both have an additional
operator for constructing maps.  It looks like `S.mapBy(x => e)` in Quint and
$[x \in S \mapsto e]$ in $\tla{}$. This operator is essential to our discussion.
I will talk about it in [Section 2][].
 

**What about types?** Perhaps, the biggest differentiator between maps in
different programming languages is whether a map may contain values of
incompatible types. In statically-typed languages (e.g., Rust), the answer is
usually "No", whereas in dynamically-typed languages (e.g., Python), the answer
is "Yes". Similar to that, Quint answers with "No" to this question, and
$\tla{}$ answers with "Yes".

<a id="dualism" />
## 2. The map-function dualism

If you know $\tla{}$, you must have noticed that what I have been calling a
*map* is actually called a *function* in $\tla{}$. This may be confusing, as
functions in programming languages are different from maps in many ways.
However, there is a very good reason for why maps are called functions in
$\tla{}$. If you were to math classes, you probably remember the [Sign
function][]. It is usually defined over real numbers, but I will define it over
the set of all integers $\mathbb{Z}$. In the spirit of math classes, we would
say that $sgn: \mathbb{Z} \rightarrow \mathbb{Z}$ is a function that is defined as
follows:

$$sgn(n) =
\begin{cases}
-1, & \text{if $n < 0$} \\
0,  & \text{if $n = 0$} \\
1, & \text{if $n > 0$} \\
\end{cases}$$

Similar to the school math, $\tla{}$ offers us a way to write the above
function `sgn` as follows:

$[n \in Int \mapsto \texttt{IF } n < 0 \texttt{ THEN } -1 \texttt{ ELSE } (\texttt{IF } n = 0 \texttt{ THEN } 0 \texttt{ ELSE } 1)]$

Since Quint is following the logic of $\tla{}$, it is possible to write the
same in Quint:

```quint
Int.mapBy(n => if (n < 0) -1 else (if (n == 0) 0 else 1))
```

Now, it all makes sense in math, but having a map over a set of all integers
sounds like it would require an infinite memory supply. In theory, it does not
have to be the case though, since all elements are mapped by the same law in
the case of `sgn`. However, maps are represented as immutable maps
in the Quint REPL, which is implemented in TypeScript. So Quint REPL would give
up immediately on the above map:

```quint
$ quint
>>> Int.mapBy(n => if (n < 0) -1 else (if (n == 0) 0 else 1))
runtime error: error: [QNT501] Infinite set Int is non-enumerable
```

:information_source: Actually, the set of all integers is enumerable. What is
meant here is that the Quint simulator is trying to enumerate all of the set
members to construct a map, and it is clear that it would not be able to do
that for an infinite set in finite time. Again, the simulator could be improved
to simply cache the lambda expression instead of populating an actual map in
this case. We simply did not have time to implement that.

To be able to evaluate our map in REPL, we could define our map over a small
finite set. For example, we could define it over the interval $[-2^7, 2^7)$:

```quint
$ quint
>>> pure val m = (-2^7).to(2^7 - 1).mapBy(n => if (n < 0) -1 else (if (n == 0) 0 else 1))
>>> m.get(55)
1
>>> m.get(-42)
-1
```

:information_source: The Quint simulator may internally represent `m` as an
immutable TypeScript map (and it currently does). This looks wasteful
:do_not_litter:.  I don't know anyone who would represent the sign function as
a map in a programming language. What is important to us: *We are writing
specifications to ease our understanding and reasoning about protocols*. Hence,
*we should not expect our specifications to be memory-efficient*. After all, if
our specification was as efficient as the implementation, why would we need the
implementation? If using a map makes the rest of your specification simpler,
then use a map.

Instead of using a map in our example, we could simply define an operator in
Quint (and similar in $\tla{}$):

```quint
pure def sgnf(n) = if (n < 0) -1 else (if (n == 0) 0 else 1)
```

In this case, we would not have to worry about memory limitations. Our
definition of `sgnf` is quite similar to a definition in a programming
language, where it would be actually a function. However, notice that there are
a few limitations to this approach:

 - You cannot store `sgnf` as a value of a variable. (This is possible in
   functional languages though.)

 - You cannot easily do a point-wise update similar to `set(key, value)`.
 
 - You cannot easily extract the function domain similar to `keys()`.

## 3. Incremental construction vs. immediate construction

Essentially, there are two ways to construct and use maps:

 1. **Incremental**: Start with an empty map and populate it when needed. This
 is how it is done in programming languages.

 1. **Immediate**: Declare a map over its domain (the keys) right away and
 change the associated values when needed. This is how it is done in
 math/$\tla{}$.

The incremental construction is the only way to build a map in many programming
languages I know. [Dict comprehensions][] in Python are perhaps a rare
exception to this. If you have more examples of languages that would allow for
something like `mapBy` out of the box, I would really love to know about them.

I believe that there is a simple explanation for why maps are constructed
incrementally. When you are writing a program, it has to be reasonably
efficient.  This is why nobody wants to pay an upfront cost of constructing a map
that is filled, say, with a lot of zeroes or other default values. Not only
would it waste CPU cycles, it would also introduce massive memory. After all,
maps are implemented via hash tables or balanced trees.


[Section 2]: #dualism
[Quint]: https://github.com/informalsystems/quint
[TLA+]: https://lamport.azurewebsites.net/tla/tla.html
[Coin in Quint]: https://github.com/informalsystems/quint/blob/main/tutorials/lesson3-anatomy/coin.md
[coin.qnt]: https://github.com/informalsystems/quint/blob/main/tutorials/lesson3-anatomy/coin.qnt
[Coin in Solidity]: https://docs.soliditylang.org/en/v0.8.17/introduction-to-smart-contracts.html#subcurrency-example
[TLA+ Functions]: https://apalache.informal.systems/docs/lang/functions.html
[Quint REPL]: https://github.com/informalsystems/quint/blob/main/tutorials/repl/repl.md
[Sign function]: https://en.wikipedia.org/wiki/Sign_function
[Dict comprehensions]: https://peps.python.org/pep-0274/
