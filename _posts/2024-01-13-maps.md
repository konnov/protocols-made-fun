---
layout: post
title: "You should not care about memory in protocol specifications"
date: 2024-01-13
categories: quint
quint: true
typescript: true
math: true
---

I have written about 1100 lines of [Quint][] over this week. Similar to my
experience of writing [TLA+][] specifications, what I noticed again is that
there is a big difference in my specification writing style that depends on
where I start from:

 1. **Source code.** This is the case when a protocol already has an
 implementation. In this case, there is a high chance that the code is the only
 reliable source of truth. Even if there is a high-level protocol
 specification, it either too imprecise or outdated. Arguably, having an
 outdated protocol specification is still better than having no specification
 at all. Typically, the code is "working", but it is not exactly clear what
 happens if things "go wrong".

 1. **Specification in English.** This is the case when a protocol is still in
 the design phase. The project may already have a code prototype, but there is
 a lot of uncertainty about failure scenarios. Typically, the only known thing
 known at this stage is the "happy path", that is, an example of how the
 protocol is supposed to work, when "nothing wrong" happens.

This time I started with the source code, having essentially no specification.
When you are starting with the code, it is very tempting to use exactly the
same data structures and operations, as you see in the code. This is usually a
mistake! The rule that I have learned over multiple iterations is as follows:

*The data structures in a protocol specification shall be more abstract than
the data structures in the source code.*

Every time I deviate from this rule, I have to re-learn it. There are many
instances of this rule. In this blog post, I am focusing only on one instance
of the rule: The use of maps and the memory considerations that are related to
this data structure.

## 1. What are maps?

If you are developing software, there is a very good chance that you have been
using maps. They have slightly different names in different programming
languages: `HashMap` and `SortedMap` in Java/Scala, a `map` in Go, `HashMap`
and `BTreeMap` in Rust, dictionaries in Python, `mapping` in Solidity, etc.
These data structures have slightly different names in different programming
languages but they all have more or less the same abstract behavior. Since
there is no common denominator in programming languages, I am using [Quint
REPL][] to demonstrate this abstract behavior:

 1. **Construct a map**. Construct an empty map. Alternatively, construct a non-empty
 map by enumerating key-value pairs. This is done with `Map(...)` in Quint:
   ```quint
   $ quint
   >>> Map()
   Map()
   >>> Map("alice" -> 3, "bob" -> 5)
   Map("alice" -> 3, "bob" -> 5)
   ```

 1. **Add or update a key-value pair**. Bind a value to a key in a map. For example,
 bind the value 42 to the key `"igor"`. Importantly, if the map already has a
 value bound to the key, update the entry, so the key becomes associated with
 the new value. This is done with `put` in Quint:
   ```quint
   $ quint
   >>> Map().put("igor", 42)
   Map("igor", 2024)
   >>> Map("igor" -> 41, "bob" -> 5).put("igor", 42)
   Map("igor" -> 42, "bob" -> 5)
   ```

 1. **Update a key-value pair**. If a value $v_1$ is bound to a key $k$ in a
 map, then bind a new value $v_2$ to the key $k$. If the map does not have a
 value for the key $k$, then the behavior is either undefined, or an error
 is expected (this varies from a language to language). This is done
 with `set` in Quint:
   ```quint
   $ quint
   >>> Map("igor" -> 41, "bob" -> 5).set("igor", 42)
   Map("igor" -> 42, "bob" -> 5)
   >>> Map().set("igor", 42)
   runtime error: error: [QNT507] Called 'set' with a non-existing key
    ```

 1. **Retrieve the value.** Given a key $k$, retrieve the value bound to the
 key in a map. Usually, it is assumed that there must be such a value.
 Otherwise, the behavior is either undefined, or an error is expected.
 This is done with `get` in Quint:
   ```quint
   $ quint
   >>> Map("igor" -> 41, "bob" -> 5).get("igor")
   Map("igor" -> 42, "bob" -> 5)
   >>> Map().get("igor")
   runtime error: error: [QNT507] Called 'get' with a non-existing key
   ```

 1. **Get the keys.** Get the keys that are bound to some values in a map.
 What is actually returned, depends on a programming language. It can be a
 list, an array, a set, or an iterator. Quint returns the set of keys:
   ```quint
   $ quint
   >>> Map("alice" -> 3, "bob" -> 7).keys()
   Set("alice", "bob")
   ```

Programming languages usually have another operation that iterates over
key-value pairs. The way it looks like usually depends on the language. I am
omitting this operation here, as it can be implemented via a combination of
`keys` and `get`. Similar to that, many languages have an operation
`m.contains(k)` for checking whether a key $k$ has a value bound to $k$ in a
map $m$. This one can be implemented via `m.keys()` and its set membership:
`m.keys().contains(k)`.

If you know $\tla{}$ or Quint, you know that they both have an additional
operator for constructing maps.  It looks like `S.mapBy(x => e)` in Quint and
$[x \in S \mapsto e]$ in $\tla{}$. This operator is essential to our discussion.
I will talk about it in [Section 2][].
 

**What about types?** Perhaps, the biggest differentiator between maps in
different programming languages is whether a map may contain values of
incompatible types. In statically-typed languages (e.g., Rust), the answer is
usually "No", whereas in dynamically-typed languages (e.g., Python), the answer
is "Yes". Similar to that, Quint answers with "No" to this question, and
$\tla{}$ answers with "Yes".

<a id="dualism" />
## 2. The map-function dualism

If you know $\tla{}$, you must have noticed that what I have been calling a
*map* is actually called a *function* in $\tla{}$. This may be confusing, as
functions in programming languages are different from maps in many ways.
However, there is a very good reason for why maps are called functions in
$\tla{}$. If you were to math classes, you probably remember the [Sign
function][]. It is usually defined over real numbers, but I will define it over
integers. In the spirit of math classes, we would say that $sgn: \mathbb{Z}
\mapsto \mathbb{Z}$ is a function that is defined as follows:

$$sgn(n) =
\begin{cases}
-1, & \text{if $n < 0$} \\
0,  & \text{if $n = 0$} \\
1, & \text{if $n > 0$} \\
\end{cases}$$

Similar to the school math, $\tla{}$ offers us a way to write the above
function `sgn` as follows:

$[n \in Int \mapsto \texttt{IF } n < 0 \texttt{ THEN } -1 \texttt{ ELSE } (\texttt{IF } n = 0 \texttt{ THEN } 0 \texttt{ ELSE } 1)]$

Since Quint is following the logic of $\tla{}$, it is possible to write the
same in Quint:

```quint
Int.mapBy(n => if (n < 0) -1 else (if (n == 0) 0 else 1))
```

Now, it all made sense in math, but having a map over a set of all integers
sounds like it would require an infinite memory supply.

Essentially, there are two ways of using maps:

 1. The programming languages way: Start with an empty map and populate it when
 needed.

 1. The math/$\tla{}$ way: Declare a map over its domain (the keys) right away
 and change the associated keys when needed.


[Section 2]: #dualism
[Quint]: https://github.com/informalsystems/quint
[TLA+]: https://lamport.azurewebsites.net/tla/tla.html
[Coin in Quint]: https://github.com/informalsystems/quint/blob/main/tutorials/lesson3-anatomy/coin.md
[coin.qnt]: https://github.com/informalsystems/quint/blob/main/tutorials/lesson3-anatomy/coin.qnt
[Coin in Solidity]: https://docs.soliditylang.org/en/v0.8.17/introduction-to-smart-contracts.html#subcurrency-example
[TLA+ Functions]: https://apalache.informal.systems/docs/lang/functions.html
[Quint REPL]: https://github.com/informalsystems/quint/blob/main/tutorials/repl/repl.md
[Sign function]: https://en.wikipedia.org/wiki/Sign_function
