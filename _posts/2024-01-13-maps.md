---
layout: post
title: "You should not care about memory in protocol specifications"
date: 2024-01-13
categories: quint
quint: true
typescript: true
math: true
---

*...Unless you are specifying a garbage collector.*

I have written about 1100 lines of [Quint][] over this week. Similar to my
experience of writing [TLA+][] specifications, what I noticed again is that
there is a big difference in my specification style that depends on where I
start from:

 1. **Source code.** This is the case when a protocol already has an
 implementation. In this case, there is a high chance that the code is the only
 reliable source of truth. Even if there is a high-level protocol
 specification, it either too imprecise or outdated. Arguably, having an
 outdated protocol specification is still better than having no specification
 at all. Typically, the code is "working", but it is not exactly clear what
 happens if things "go wrong".

 1. **Specification in English.** This is the case when a protocol is still in
 the design phase. The project may already have a code prototype, but there is
 a lot of uncertainty about failure scenarios. Typically, the only known thing
 known at this stage is the "happy path", that is, an example of how the
 protocol is supposed to work, when "nothing wrong" happens.

This time I started with the source code, having essentially no specification.
When you are starting with the code, it is very tempting to use exactly the
same data structures and operations, as you see them in the code. This is
usually a mistake! The rule that I have learned over multiple iterations is as
follows:

*The data structures in a protocol specification shall be more abstract than
the data structures in the source code.*

Every time I deviate from this rule, I have to re-learn it. There are many
instances of this rule. In this blog post, I am focusing only on one instance
of the rule: The use of maps and the memory considerations that are related to
this data structure.

## 1. What are maps?

If you are developing software, there is a very good chance that you have been
using maps. They have slightly different names in different programming
languages: `HashMap` and `SortedMap` in Java/Scala, a `map` in Go, `HashMap`
and `BTreeMap` in Rust, dictionaries in Python, `mapping` in Solidity, etc.
These data structures have slightly different names in different programming
languages but they all have more or less the same abstract behavior. Since
there is no common denominator in programming languages, I am using [Quint
REPL][] to demonstrate this abstract behavior:

 1. **Construct a map**. Construct an empty map. Alternatively, construct a non-empty
 map by enumerating key-value pairs. This is done with `Map(...)` in Quint:
   ```quint
   $ quint
   >>> Map()
   Map()
   >>> Map("alice" -> 3, "bob" -> 5)
   Map("alice" -> 3, "bob" -> 5)
   ```

 1. **Add or update a key-value pair**. Bind a value to a key in a map. For example,
 bind the value 42 to the key `"igor"`. Importantly, if the map already has a
 value bound to the key, update the entry, so the key becomes associated with
 the new value. This is done with `put` in Quint:
   ```quint
   $ quint
   >>> Map().put("igor", 42)
   Map("igor", 2024)
   >>> Map("igor" -> 41, "bob" -> 5).put("igor", 42)
   Map("igor" -> 42, "bob" -> 5)
   ```

 1. **Update a key-value pair**. If a value $v_1$ is bound to a key $k$ in a
 map, then bind a new value $v_2$ to the key $k$. If the map does not have a
 value for the key $k$, then the behavior is either undefined, or an error
 is expected (this varies from a language to language). This is done
 with `set` in Quint:
   ```quint
   $ quint
   >>> Map("igor" -> 41, "bob" -> 5).set("igor", 42)
   Map("igor" -> 42, "bob" -> 5)
   >>> Map().set("igor", 42)
   runtime error: error: [QNT507] Called 'set' with a non-existing key
    ```

 1. **Retrieve the value.** Given a key $k$, retrieve the value bound to the
 key in a map. Usually, it is assumed that there must be such a value.
 Otherwise, the behavior is either undefined, or an error is expected.
 This is done with `get` in Quint:
   ```quint
   $ quint
   >>> Map("igor" -> 41, "bob" -> 5).get("igor")
   Map("igor" -> 42, "bob" -> 5)
   >>> Map().get("igor")
   runtime error: error: [QNT507] Called 'get' with a non-existing key
   ```

 1. **Get the keys.** Get the keys that are bound to some values in a map.
 What is actually returned, depends on a programming language. It can be a
 list, an array, a set, or an iterator. Quint returns the set of keys:
   ```quint
   $ quint
   >>> Map("alice" -> 3, "bob" -> 7).keys()
   Set("alice", "bob")
   ```

:raising_hand: Programming languages usually have another operation that
iterates over key-value pairs. The way it looks like usually depends on the
language. I am omitting this operation here, as it can be implemented via a
combination of `keys`, `get`, and iteration. Similar to that, many languages
have an operation `m.contains(k)` for checking whether a key $k$ has a value
bound to $k$ in a map $m$. This one can be implemented via `m.keys()` and its
set membership: `m.keys().contains(k)`.

:information_source: If you know $\tla{}$ or Quint, you know that they both
have an additional operator for constructing maps.  It looks like `S.mapBy(x =>
e)` in Quint and $[x \in S \mapsto e]$ in $\tla{}$. This operator is essential
to our discussion.  I will talk about it in [Section 2][].

:warning: I have omitted one more operation that we would often find in a map.
Can you figure out which one is it? Actually, I forgot about it when writing
this text, since this operation is almost never used in protocol
specifications.
 
**What about types?** Perhaps, the biggest differentiator between maps in
different programming languages is whether a map may contain values of
incompatible types. In statically-typed languages (e.g., Rust), the answer is
usually "No", whereas in dynamically-typed languages (e.g., Python), the answer
is "Yes". Similar to that, Quint answers with "No" to this question, and
$\tla{}$ answers with "Yes".

<a id="dualism" />
## 2. The map-function dualism

If you know $\tla{}$, you must have noticed that what I have been calling a
*map* is actually called a *function* in $\tla{}$. This may be confusing, as
functions in programming languages are different from maps in many ways.
However, there is a very good reason for why maps are called functions in
$\tla{}$. If you were to math classes, you probably remember the [Sign
function][]. It is usually defined over real numbers, but I will define it over
the set of all integers $\mathbb{Z}$. In the spirit of math classes, we would
say that $sgn: \mathbb{Z} \rightarrow \mathbb{Z}$ is a function that is defined as
follows:

$$sgn(n) =
\begin{cases}
-1, & \text{if $n < 0$} \\
0,  & \text{if $n = 0$} \\
1, & \text{if $n > 0$} \\
\end{cases}$$

Similar to the school math, $\tla{}$ offers us a way to write the above
function `sgn` as follows:

$[n \in Int \mapsto \texttt{IF } n < 0 \texttt{ THEN } -1 \texttt{ ELSE } (\texttt{IF } n = 0 \texttt{ THEN } 0 \texttt{ ELSE } 1)]$

Since Quint is following the logic of $\tla{}$, it is possible to write the
same in Quint:

```quint
Int.mapBy(n => if (n < 0) -1 else (if (n == 0) 0 else 1))
```

Now, it all makes sense in math, but having a map over a set of all integers
sounds like it would require an infinite memory supply. In theory, it does not
have to be the case though, since all elements are mapped by the same law in
the case of `sgn`. However, maps are represented as immutable maps
in the Quint REPL, which is implemented in TypeScript. So Quint REPL would give
up immediately on the above map:

```quint
$ quint
>>> Int.mapBy(n => if (n < 0) -1 else (if (n == 0) 0 else 1))
runtime error: error: [QNT501] Infinite set Int is non-enumerable
```

:information_source: Actually, the set of all integers is enumerable. What is
meant here is that the Quint simulator is trying to enumerate all of the set
members to construct a map, and it is clear that it would not be able to do
that for an infinite set in finite time. Again, the simulator could be improved
to simply cache the lambda expression instead of populating an actual map in
this case. We simply did not have time to implement that.

To be able to evaluate our map in REPL, we could define our map over a small
finite set. For example, we could define it over the interval $[-2^7, 2^7)$:

```quint
$ quint
>>> pure val m = (-2^7).to(2^7 - 1).mapBy(n => if (n < 0) -1 else (if (n == 0) 0 else 1))
>>> m.get(55)
1
>>> m.get(-42)
-1
```

:information_source: The Quint simulator may internally represent `m` as an
immutable TypeScript map (and it currently does). This looks wasteful
:do_not_litter:.  I don't know anyone who would represent the sign function as
a map in a programming language. What is important to us:

*We are writing specifications to ease our understanding and reasoning about
protocols. Hence, we should not expect our specifications to be
memory-efficient*.

After all, if our specification was as efficient as the implementation, why
would we need the implementation? If using a map makes the rest of your
specification simpler, then use a map.

Instead of using a map in our example, we could simply define an operator in
Quint (and similar in $\tla{}$):

```quint
pure def sgnf(n) = if (n < 0) -1 else (if (n == 0) 0 else 1)
```

In this case, we would not have to worry about memory limitations. Our
definition of `sgnf` is quite similar to a definition in a programming
language, where it would be actually a function. However, notice that there are
a few limitations to this approach:

 - You cannot store `sgnf` as a value of a variable. (This is possible in
   functional languages though.)

 - You cannot easily do a point-wise update similar to `set(key, value)`.
 
 - You cannot easily extract the function domain similar to `keys()`.

:information_source: If you would like to learn more about $\tla{}$ functions
(which are also Quint maps) and how they compare to maps in programming
languages, the Apalache manual has a detailed discussion on [TLA+ Functions][].

<a id="construction" />
## 3. Incremental construction vs. immediate construction

Essentially, there are two ways to construct and use maps:

 1. **Incremental**: Start with an empty map and populate it when needed. This
 is how it is done in programming languages.

 1. **Immediate**: Declare a map over its domain (the keys) right away and
 change the associated values when needed. This is how it is done in
 math/$\tla{}$.

The incremental construction is the only way to build a map in many programming
languages that I know. [Dict comprehensions][] in Python are perhaps a rare
exception to this. If you have more examples of languages that would allow for
something like `mapBy` out of the box, I would really love to know about them.

I believe that there is a simple explanation for why maps are constructed
incrementally in source code. When you are writing a program, it has to be
reasonably efficient.  This is why nobody wants to pay an upfront cost of
constructing a map that is filled, say, with a lot of zeroes or other default
values. Not only would it waste CPU cycles, it would also introduce massive
memory overhead. After all, maps are implemented via hash tables or balanced
trees.

What is important to understand is that when you are writing a protocol
specification, maps are just another building block, similar to sets. Both sets
and maps have non-trivial associated costs in programming languages. This does
not matter in protocol specifications:

*First, you have to understand how to do something right. Second, think about
how to the right thing efficiently.*

## 4. Thoughts in action

There was a lot of abstract text. Let's work through a concrete example. I
cannot show you the specification that I wrote over this week. Yet, there is a
simple example called [coin.qnt][] in the Quint repository. This example
specifies the behavior of a Solidity smart contract, see [Coin in Solidity][]
for details. If you like to understand the specification, there is a detailed
tutorial called [Coin in Quint][]. In the following, I would assume that you
understand what is going on in [coin.qnt][].

We will compare the two styles of using maps, namely, immediate construction
and incremental construction, which we have discussed in [Section 3][].

### 4.1. Immediate construction

The specification [coin.qnt][] is written in the style of immediate
construction. I am going to highlight only the important pieces.

The specification is quite small. It declares a map called `balances` in
[Line 52][]:

```quint
    // the balances in the subcurrency tokens
    var balances: Addr -> UInt
```

Since we want to initialize the variable `balances` in one go, instead of
constructing it step by step, we have to decide on the set of keys (also,
called the domain) of `balances`. As this specification stems from the [Coin in
Solidity][], the most straightforward answer is: The set of keys is the set of
all Ethereum addresses. An [Ethereum address][] is 20 bytes long. This makes
$8^{20}$ addresses. Of course, if this was essential for the smart contract in
question, we could define this set. However, it is not really important.

One way to deal with things like the set of all addresses is to define a constant:

```quint
// all 20-byte strings
const ADDR: Set[Addr]
```

By doing so, we could reason about the protocol without fixing the set of all
addresses. For testing purposes, we could instantiate `ADDR` with a small set
of addresses. In [coin.qnt][], we do not declare `ADDR` as a constant, which
would require us to declare another module for testing, but we simply fix it to
be a small set of addresses right away in [Line 47][]:

```quint
pure val ADDR = Set("null", "alice", "bob", "charlie", "eve")
```

Having the set of all addresses, we can immediately initialize the balances, see
[Line 62][]. I have replaced the non-essential code with `[...]`:

```quint
// state initialization
action init = {
  // [...]
  all {
    // [...]
    balances' = ADDR.mapBy(a => 0)
  }
}
```

This initialization is surprisingly consistent with how maps are initialized in
Solidity. They are initialized with the default values. That is, with all
zeroes in this case.

Now let's have a look at how `balances` is queried and updated. We will only
look at the action `send` in [Line 94][], all non-essential code is replaced
with `[...]`:

```quint
action send(sender: Addr, receiver: Addr, amount: UInt): bool = all {
  require(not(amount > balances.get(sender))),
  if (sender == receiver) {
    // [...]
  } else {
    val newSenderBal = balances.get(sender) - amount
    val newReceiverBal = balances.get(receiver) + amount
    all {
      // [...]
      balances' =
        balances.set(sender, newSenderBal).set(receiver, newReceiverBal)
    }
  },
  // [...]
}
```

There are a few things to note here:

 - We simply use `balances.get(sender)` and `balances.get(receiver)` instead of
   testing, whether `sender` and `receiver` belong to the `balances.keys()`. We
   know they do, since we have initialized `balances` over all addresses from
   `ADDR`.

 - We do not have to think about whether to insert a new key-value pair, or to
   update an existing one. Again, we know that that all keys from `ADDR` are
   present in `balances`. So we are simply using `set`.

There is not much to talk about here. The specification is quite simple. This
is actually the point! We do not have to do any memory-related manipulations
over maps. Instead, we focus on the logic of the smart contract.

Now we are going to compare this simple approach with the "standard" approach
of incremental construction.

### 4.2. Incremental construction


[Section 2]: #dualism
[Section 3]: #construction
[Line 47]: https://github.com/informalsystems/quint/blob/2c66d9376093e1c8a655dffeef011476d21d7e35/tutorials/lesson3-anatomy/coin.qnt#L47
[Line 52]: https://github.com/informalsystems/quint/blob/2c66d9376093e1c8a655dffeef011476d21d7e35/tutorials/lesson3-anatomy/coin.qnt#L52
[Line 62]: https://github.com/informalsystems/quint/blob/2c66d9376093e1c8a655dffeef011476d21d7e35/tutorials/lesson3-anatomy/coin.qnt#L62-L71
[Line 94]: https://github.com/informalsystems/quint/blob/2c66d9376093e1c8a655dffeef011476d21d7e35/tutorials/lesson3-anatomy/coin.qnt#L94
[Ethereum address]: https://info.etherscan.com/what-is-an-ethereum-address/#:~:text=An%20Ethereum%20address%20is%20a,with%200x%20appended%20in%20front.
[Quint]: https://github.com/informalsystems/quint
[TLA+]: https://lamport.azurewebsites.net/tla/tla.html
[Coin in Quint]: https://github.com/informalsystems/quint/blob/main/tutorials/lesson3-anatomy/coin.md
[coin.qnt]: https://github.com/informalsystems/quint/blob/main/tutorials/lesson3-anatomy/coin.qnt
[Coin in Solidity]: https://docs.soliditylang.org/en/v0.8.17/introduction-to-smart-contracts.html#subcurrency-example
[TLA+ Functions]: https://apalache.informal.systems/docs/lang/functions.html
[Quint REPL]: https://github.com/informalsystems/quint/blob/main/tutorials/repl/repl.md
[Sign function]: https://en.wikipedia.org/wiki/Sign_function
[Dict comprehensions]: https://peps.python.org/pep-0274/
